<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
     xmlns:georss="http://www.georss.org/georss"
     xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#"
     xmlns:media="http://search.yahoo.com/mrss/"><channel>
  <title>Core Dump RSS</title>
  <atom:link href="https://veera.app/rss.xml" rel="self" type="application/rss+xml" />
  <link>https://veera.app/</link>
  <description><![CDATA[]]></description>
  <language>en</language>
  <pubDate>Thu, 19 May 2022 19:25:35 -0400</pubDate>
  <lastBuildDate>Thu, 19 May 2022 19:25:35 -0400</lastBuildDate>
  <generator>Emacs 27.1 Org-mode 9.4.6</generator>
  <webMaster>sveera.2001@gmail.com (Veera Sivarajan)</webMaster>
  <image>
    <url>https://orgmode.org/img/org-mode-unicorn-logo.png</url>
    <title>Core Dump RSS</title>
    <link>https://veera.app/</link>
  </image>


  <item>
    <title>file:/home/veera/Projects/Blog/local/streams_and_iterators.org</title>
    <link>https://veera.app/streams_and_iterators.html</link>
    <author>sveera.2001@gmail.com (Veera Sivarajan)</author>
    <guid isPermaLink="false">https://veera.app/streams_and_iterators.html</guid>
    <pubDate>Sat, 16 Apr 2022 00:00:00 -0400</pubDate>

    <description><![CDATA[<p>
    Intro
    Iterators are a simple concept which adds a lot of expressive power to language. It is an interface to successively access each element in a collection. 
    </p>

    <p>
    Main goal of iterators is to separate the algorithm required to enumerate the elements from the code that uses all the elements.
    </p>

    <p>
    Main goal of iterators is to separate the code that finds successive elements in a container and the code that uses successive elements.
    History
    Iterators were first introduced in Barbara Liskov's CLU programming language. To learn more about the language refer to section 10.3.10 in this paper <a href="https://dl.acm.org/doi/pdf/10.1145/234286.1057826">A History of CLU</a>.
    </p>

    <p>
    CLU was created starting in 1973 and first appeared in 1975.
    Difference between Streams and Iterators
    Iterators are imperative as successive calls changes the internal state. Iterator uses a mutable state. <code>.next()</code> returns a different value.
    </p>

    <p>
    Streams are functional as their internal state does not change.
    Conceptual Building
    Explain how one can build an iterator from scratch. Explain the required variables: starting value, condition to check if that's the end, and how to increment.
    </p>

    <p>
    Professor Moss part of the group that worked on designing and implementing CLU programming language. Refer to this <a href="https://youtu.be/_jTc1BTFdIo?t=1063">video</a>.
    </p>
    ]]></description>
  </item>
  <item>
    <title>file:/home/veera/Projects/Blog/local/rena's_memory_model.org</title>
    <link>https://veera.app/rena's_memory_model.html</link>
    <author>sveera.2001@gmail.com (Veera Sivarajan)</author>
    <guid isPermaLink="false">https://veera.app/rena's_memory_model.html</guid>
    <pubDate>Thu, 25 Nov 2021 00:00:00 -0500</pubDate>

    <description><![CDATA[<p>
    <a href="https://github.com/veera-sivarajan/rena">Rena</a> is my implementation of lox tree-walk interpreter in Rust. I'm rewriting it in Rust to familiarize myself with the borrow checker and the fancy toolchain it offers. In this post, I'll explain how I implemented a simple environment for the interpreter. 
    Structure
    The environment is structured as a vector of hashmaps and is initialized with an empty hashmap to represent the global scope. Every new block in the source code inserts an empty hashmap at the head of the vector and exiting out of a block removes a hashmap from the head. The environment combines these three properties to support nesting and shadowing of values in the memory.  
    </p>
    <div class="org-src-container">
    <pre class="src src-rust"><span class="org-keyword">pub</span> <span class="org-keyword">struct</span> <span class="org-type">Environment</span> {
    <span class="org-variable-name">frame_list</span>: <span class="org-type">Vec</span>&lt;<span class="org-type">HashMap</span>&lt;<span class="org-type">String</span>, <span class="org-type">Value</span>&gt;&gt;,
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">new</span>() -&gt; <span class="org-type">Environment</span> {
    <span class="org-keyword">let</span> <span class="org-keyword">mut</span> <span class="org-variable-name">frames</span> = <span class="org-type">Vec</span>::new();
    frames.push(<span class="org-type">HashMap</span>::new());

    <span class="org-type">Environment</span> {
    <span class="org-variable-name">frame_list</span>: frames,
    }
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">new_scope</span>(&amp;<span class="org-keyword">mut</span> <span class="org-keyword">self</span>) {
    <span class="org-keyword">self</span>.frame_list.insert(0, <span class="org-type">HashMap</span>::new());
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">exit_scope</span>(&amp;<span class="org-keyword">mut</span> <span class="org-keyword">self</span>) {
    <span class="org-keyword">self</span>.frame_list.remove(0);
    }
    </pre>
    </div>
    <p>
    Declaring New Values
    When the interpreter encounters a new block in the parsed source code, it first calls <code>new_scope()</code> to initialize a new hashmap for the block. So when new values are declared inside the block, they can be safely inserted in the first hashmap of the vector which represents the innermost scope. 
    </p>
    <div class="org-src-container">
    <pre class="src src-rust"><span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">define</span>(&amp;<span class="org-keyword">mut</span> <span class="org-keyword">self</span>, <span class="org-variable-name">name</span>: <span class="org-type">String</span>, <span class="org-variable-name">value</span>: <span class="org-type">Value</span>) -&gt; <span class="org-type">Result</span>&lt;(), <span class="org-type">LoxError</span>&gt; {
    <span class="org-keyword">if</span> <span class="org-keyword">let</span> <span class="org-type">Some</span>(frame) = <span class="org-keyword">self</span>.frame_list.get_mut(0) {
    frame.insert(name, value);
    <span class="org-type">Ok</span>(())
    } <span class="org-keyword">else</span> {
    <span class="org-preprocessor">error!</span>(<span class="org-string">"Frame not available."</span>)
    }
    }
    </pre>
    </div>
    <p>
    Fetching and Assigning Values
    <code>fetch()</code> is used to fetch a value from the environment and <code>assign()</code> is used to assign a new value to a predefined key. Both the functions are required to climb up from the starting scope to the global scope until a hashmap containing the given key is found. This is accomplished by iterating through each hashmap in the vector and performing the fetch or assign operation only if a hashmap contains the key. If the key is not found in any hashmap, the value being searched for has not been declared.
    </p>

    <p>
    For example, to fetch a variable <code>a</code> declared in the global scope and used inside a block statement, the interpreter will first check the first hashmap in the vector (innermost scope) for the variable name and will not find it. So it will proceed to check the second hashmap (global scope) and since this hashmap contains the variable's key the function will return the value associated with the key.  
    </p>
    <div class="org-src-container">
    <pre class="src src-rust"><span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">fetch</span>(&amp;<span class="org-keyword">self</span>, <span class="org-variable-name">name</span>: <span class="org-type">String</span>) -&gt; <span class="org-type">Option</span>&lt;&amp;<span class="org-type">Value</span>&gt; {
    <span class="org-keyword">for</span> <span class="org-variable-name">frame</span> <span class="org-keyword">in</span> &amp;<span class="org-keyword">self</span>.frame_list {
    <span class="org-keyword">if</span> frame.contains_key(&amp;name) {
    <span class="org-keyword">return</span> frame.get(&amp;name);
    }
    }
    <span class="org-type">None</span>
    }

    <span class="org-keyword">pub</span> <span class="org-keyword">fn</span> <span class="org-function-name">assign</span>(&amp;<span class="org-keyword">mut</span> <span class="org-keyword">self</span>, <span class="org-variable-name">name</span>: <span class="org-type">String</span>, <span class="org-variable-name">value</span>: <span class="org-type">Value</span>) -&gt; <span class="org-type">Result</span>&lt;<span class="org-type">Value</span>, <span class="org-type">LoxError</span>&gt; {
    <span class="org-keyword">for</span> <span class="org-variable-name">frame</span> <span class="org-keyword">in</span> &amp;<span class="org-keyword">mut</span> <span class="org-keyword">self</span>.frame_list {
    <span class="org-keyword">if</span> frame.contains_key(&amp;name) {
    frame.insert(name, value.clone());
    <span class="org-keyword">return</span> <span class="org-type">Ok</span>(value);
    }
    }
    <span class="org-preprocessor">error!</span>(<span class="org-string">"Undefined variable."</span>)
    }
    </pre>
    </div>
    <p>
    The End
    Here's a pictorial representation of the environment for the source code below. The first element represents the innermost scope and the following elements represent the enclosing outer scopes. 
    <img src="imgs/scopes3.png" alt="scopes3.png">
    </p>
    <pre class="example">
    var a = 1;
    var b = 2;
    {
    var c = 100;
    print a; // 1
    {
    var d = 4;
    {
    var e = 5;
    c = 3;
    print c; // 3
    }
    }
    }
    </pre>
    <p>
    Compared to the implementation provided in the book, my implementation sits well with the borrow checker and may be more performant and readable as it uses iteration instead of recursion to climb up the nested scopes. 
    </p>

    <p>
    Now, back to hacking :^)
    </p>

    <p>
    Edit
    A comment by <a href="https://www.reddit.com/r/rust/comments/r2tblf/comment/hm84mvq/?utm_source=share&amp;utm_medium=web2x&amp;context=3">u/Training-Ad-9425</a> mentioned that my implementation is inefficient and after referring to the <a href="https://doc.rust-lang.org/std/collections/index.html#sequences">documentation</a>, I realized that inserting and removing an element from the head of a <code>Vec</code> is a \(O(n)\) operation.
    </p>

    <p>
    To improve on that, I had two options:
    Push and pop new scopes at the tail of the vector and reverse the sequence when traversing from inner to outer scope. This would allow new scopes to be added to the environment in \(O(1)\) and traversing will remain to be \(O(n)\). 
    Replace the environment structure with <code>VecDeque</code> as it supports \(O(1)\) insertion and removal at both ends of the sequence.
    </p>

    <p>
    I implemented the first option as it would give me a chance to play with iterator's methods. You can find the update source code in the remote repository linked above.
    </p>
    ]]></description>
</item>
<item>
  <title>file:/home/veera/Projects/Blog/local/game_of_light.org</title>
  <link>https://veera.app/game_of_light.html</link>
  <author>sveera.2001@gmail.com (Veera Sivarajan)</author>
  <guid isPermaLink="false">https://veera.app/game_of_light.html</guid>
  <pubDate>Mon, 01 Nov 2021 00:00:00 -0400</pubDate>

  <description><![CDATA[<p>
  For our final project, Hayden and I are building <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Conway's Game of Life</a> simulator on a LED matrix. We will also add a controller which the audience can use to pause and play the simulation. With this project, we aim to understand how interesting patterns emerge from a small set of rules. The coordinates for the simulation will be computed on an Arduino board which will be connected to both the simulator and the controller. Along the way, we might also add features that tickles our fancy. Check this page by December, 2021 to view the final product.   
  Update
  After soldering countless wire tips to the LED matrix and Hayden's all-out effort on porting the <a href="https://github.com/veera-sivarajan/game-of-light/blob/master/gameOfLight.ino">software</a> to run on our hardware, we were able to finish the project on time and demo it during the final presentation. To see how our final project looked like, check out this <a href="https://youtu.be/IcmwVxqATL4">video</a> where we simulate a bunch of still life patterns in the game. 
  Fin
  CICS 256 has been a great learning experience as we got to work on a project of our choice instead of writing exams. I learned a great deal about electronics and how software and hardware interact with each other. I'm sure the skills I gained from this class will help me throughout my life. CICS 256 rocks! 
  </p>
  ]]></description>
</item>
<item>
  <title>file:/home/veera/Projects/Blog/local/adding_features_to_lox.org</title>
  <link>https://veera.app/adding_features_to_lox.html</link>
  <author>sveera.2001@gmail.com (Veera Sivarajan)</author>
  <guid isPermaLink="false">https://veera.app/adding_features_to_lox.html</guid>
  <pubDate>Thu, 19 Aug 2021 00:00:00 -0400</pubDate>

  <description><![CDATA[<p>
  Finally, I got time to sit down and implement a tree-walk interpreter following Bob Nystrom's <a href="https://craftinginterpreters.com/">Crafting Interpreters</a>. In this post, I'm going to explain some of the features I have added to the language. You can find my complete implementation <a href="https://github.com/veera-sivarajan/lang0">here</a>. I have also made a <a href="https://youtu.be/0P6VPOIKATg">video</a> demoing the features listed below.
  </p>

  <p>
  <b>Note:</b> This post assumes that the reader has read Part II of Crafting Interpreters and is familiar with the implementation details. 
  Anonymous Functions
  By definition, anonymous functions or lambdas are functions without an associated name. They are used when the user wants to invoke a piece of code but don't want to reuse it. This feature also solves challenge #2 in chapter 10 <i>Functions</i>. In my implementation, a lambda can be written by using the <code>lambda</code> keyword followed by the parameters inside parentheses and the body of the function in braces.
  </p>
  <div class="org-src-container">
  <pre class="src src-lox"><span class="org-comment-delimiter">// </span><span class="org-comment">lambdas in lox</span>
  <span class="org-keyword">var</span> square = lambda(num) { <span class="org-keyword">return</span> num * num; };
  <span class="org-builtin">print</span> square(5); <span class="org-comment-delimiter">// </span><span class="org-comment">25</span>
  </pre>
  </div>
  <p>
  A lambda is a primary expression that gets evaluated to a value of type <code>LambdaFunction</code>. Parsing it is exactly like parsing a function declaration but here the parser does not consume a name for the function. Finally, it wraps the parameters and the body of lambda in a AST node. 
  </p>
  <div class="org-src-container">
  <pre class="src src-cpp"><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span>&lt;Expr&gt; <span class="org-constant">Parser</span>::<span class="org-function-name">lambda</span>() {
  consume(<span class="org-constant">TokenType</span>::LEFT_PAREN, <span class="org-string">"Expect '(' after 'lambda'."</span>);
  <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;Token&gt; <span class="org-variable-name">parameters</span>;
  <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>check(<span class="org-constant">TokenType</span>::RIGHT_PAREN)) {
  <span class="org-keyword">do</span> {
  <span class="org-keyword">if</span> (parameters.size() &gt;= 10) {
  error(peek(), <span class="org-string">"Can't have more than 10 parameters."</span>);
  }
  parameters.push_back(
  consume(<span class="org-constant">TokenType</span>::IDENTIFIER, <span class="org-string">"Expect parameter name."</span>));
  } <span class="org-keyword">while</span> (match(<span class="org-constant">TokenType</span>::COMMA));
  }
  consume(<span class="org-constant">TokenType</span>::RIGHT_PAREN, <span class="org-string">"Expect ')' after parameters."</span>);
  consume(<span class="org-constant">TokenType</span>::LEFT_BRACE, <span class="org-string">"Expect '{' before lambda body."</span>);
  <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-constant">std</span>::<span class="org-type">shared_ptr</span>&lt;<span class="org-constant">Statement</span>::Stmt&gt;&gt; <span class="org-variable-name">body</span> = block();
  <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared&lt;Lambda&gt;(<span class="org-constant">std</span>::move(parameters), <span class="org-constant">std</span>::move(body));
  }
  </pre>
  </div>
  <p>
  Since these expressions don't have a name and cannot be reused like a variable or a named function, the interpreter need not store the value of the function in its environment. Instead it would create a runtime's representation of an anonymous function using the parsed value and the environment of the lambda (to allow closures to work) and return the value.
  </p>
  <div class="org-src-container">
  <pre class="src src-cpp"><span class="org-constant">std</span>::<span class="org-type">any</span> <span class="org-constant">Interpreter</span>::<span class="org-function-name">visitLambdaExpr</span>(<span class="org-constant">std</span>::<span class="org-type">shared_ptr</span>&lt;Lambda&gt; <span class="org-variable-name">expr</span>) {
  <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared&lt;LambdaFunction&gt;(expr, curr_env);
  }
  </pre>
  </div>
  <p>
  Lists
  To add a list data type into the language, the task can be divided into three small tasks:
  </p>
  <div id="outline-container-orgf7de04e" class="outline-3">
  <h3 id="orgf7de04e">Scanning</h3>
  <div class="outline-text-3" id="text-orgf7de04e">
  <p>
  Introduce two new tokens to make the scanner handle list expressions and subscripts.
  </p>
  <div class="org-src-container">
  <pre class="src src-cpp"><span class="org-keyword">case</span> <span class="org-string">'['</span>: addToken(<span class="org-constant">TokenType</span>::LEFT_BRACKET); <span class="org-keyword">break</span>;
  <span class="org-keyword">case</span> <span class="org-string">']'</span>: addToken(<span class="org-constant">TokenType</span>::RIGHT_BRACKET); <span class="org-keyword">break</span>;
  </pre>
  </div>
  </div>
  </div>
  <div id="outline-container-orgd5af34d" class="outline-3">
  <h3 id="orgd5af34d">Creating List Literals</h3>
  <div class="outline-text-3" id="text-orgd5af34d">
  <p>
  Like numbers, string, <code>true</code> and <code>false</code>, a list is a primary expression which can contain any number of comma seperated expressions. Since Lox is a dynamically typed language, these expressions can be of any type. 
  </p>

  <p>
  To learn about the grammar for lists, I found Caleb&rsquo;s blog <a href="https://calebschoepp.com/blog/2020/adding-a-list-data-type-to-lox/">post</a> to be helpful. It explained all the details related to implementing lists in a clear and concise way.
  </p>
  </div>
  <div id="outline-container-org710b2a3" class="outline-4">
  <h4 id="org710b2a3">Parsing Lists</h4>
  <div class="outline-text-4" id="text-org710b2a3">
  <p>
  Parsing a list literal is exactly like parsing the arguments of a function call but here square brackets replaces the parentheses. Internally, the parser stores a list as a vector containing expressions. The function first checks if it is a empty list. If its not, it parses each expression in the scanned list and appends it to the internal representation. In the end, it consumes the <code>]</code> and wraps the vector in a AST node.
  </p>
  <div class="org-src-container">
  <pre class="src src-cpp"><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span>&lt;Expr&gt; <span class="org-constant">Parser</span>::<span class="org-function-name">list</span>() {
  <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-constant">std</span>::<span class="org-type">shared_ptr</span>&lt;Expr&gt;&gt; <span class="org-variable-name">values</span> = {};
  <span class="org-keyword">if</span> (match(<span class="org-constant">TokenType</span>::RIGHT_BRACKET)) {
  <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared&lt;List&gt;(values);
  } <span class="org-keyword">else</span> {
  <span class="org-keyword">do</span> {
  <span class="org-keyword">if</span> (values.size() &gt;= 100) {
  error(peek(), <span class="org-string">"Can't have more than 100 elements in a list."</span>);
  }
  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span>&lt;Expr&gt; <span class="org-variable-name">value</span> = logicalOr();
  values.push_back(value);
  } <span class="org-keyword">while</span> (match(<span class="org-constant">TokenType</span>::COMMA));
  }
  consume(<span class="org-constant">TokenType</span>::RIGHT_BRACKET, <span class="org-string">"Expect ']' at end of list."</span>);
  <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared&lt;List&gt;(values);
  }
  </pre>
  </div>
  </div>
  </div>
  <div id="outline-container-org8c07672" class="outline-4">
  <h4 id="org8c07672">Interpreting Lists</h4>
  <div class="outline-text-4" id="text-org8c07672">
  <p>
  To interpret a list literal, the interpreter iterates through each element in the parsed expression, evaluates it and appends the value to runtime&rsquo;s representation of a list. Finally, like interpreting any other kind of expression, the runtime&rsquo;s value is returned. 
  </p>
  <div class="org-src-container">
  <pre class="src src-cpp"><span class="org-constant">std</span>::<span class="org-type">any</span> <span class="org-constant">Interpreter</span>::<span class="org-function-name">visitListExpr</span>(<span class="org-constant">std</span>::<span class="org-type">shared_ptr</span>&lt;List&gt; <span class="org-variable-name">expr</span>) {
  <span class="org-keyword">auto</span> <span class="org-variable-name">list</span> = <span class="org-constant">std</span>::make_shared&lt;ListType&gt;();
  <span class="org-keyword">for</span> (<span class="org-constant">std</span>::<span class="org-type">shared_ptr</span>&lt;Expr&gt; &amp;<span class="org-variable-name">value</span> : expr-&gt;values) {
  list-&gt;append(evaluate(value));
  }
  <span class="org-keyword">return</span> list;
  }
  </pre>
  </div>
  </div>
  </div>
  </div>
  <div id="outline-container-orgaaf23aa" class="outline-3">
  <h3 id="orgaaf23aa">Handling Subscript Expressions</h3>
  <div class="outline-text-3" id="text-orgaaf23aa">
  <p>
  Subscript expressions are used to get and set an element at a particular index in the list. In other words, they can be used both as a l-value and a r-value and to diffrentiate between the two and also to avoid repetition of code I have used a simple trick<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>.
  </p>

  <p>
  From the interpreter&rsquo;s point of view, the only difference between the two is the presence of a value expression. If the AST node has a value, it should assign it at index. Otherwise, it should return the value at index. So the trick is to make the parser pass a <code>nullptr</code> in the place of value expression when parsing a r-value and pass a value only when parsing a l-value. This allows the interpreter to easily differentiate between the two kinds of subscript expressions.
  </p>
  </div>
  <div id="outline-container-org9a039cf" class="outline-4">
  <h4 id="org9a039cf">Parsing Subscripts</h4>
  <div class="outline-text-4" id="text-org9a039cf">
  <p>
  Parsing the r-value is, once again, similar to parsing a function call. But instead of parsing any number of arguments, the parser will only parse a single value between the square brackets. <code>subscript()</code> calls <code>finishSubscript()</code> each time it sees a <code>[</code> to support indexing list of lists. Lastly, to wrap everything in a node, the parser stores a <code>nullptr</code> in the place of value expression to let the interpreter know that it is a r-value. 
  </p>
  <div class="org-src-container">
  <pre class="src src-cpp"><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span>&lt;Expr&gt; <span class="org-constant">Parser</span>::<span class="org-function-name">finishSubscript</span>(<span class="org-constant">std</span>::<span class="org-type">shared_ptr</span>&lt;Expr&gt; <span class="org-variable-name">name</span>) {
  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span>&lt;Expr&gt; <span class="org-variable-name">index</span> = logicalOr();
  <span class="org-type">Token</span> <span class="org-variable-name">paren</span> = consume(<span class="org-constant">TokenType</span>::RIGHT_BRACKET,
  <span class="org-string">"Expect ']' after arguments."</span>);
  <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared&lt;Subscript&gt;(name, index, <span class="org-constant">nullptr</span>, paren);
  }

  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span>&lt;Expr&gt; <span class="org-constant">Parser</span>::<span class="org-function-name">subscript</span>() {
  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span>&lt;Expr&gt; <span class="org-variable-name">expr</span> = primary();
  <span class="org-keyword">while</span> (<span class="org-constant">true</span>) {
  <span class="org-keyword">if</span> (match(<span class="org-constant">TokenType</span>::LEFT_BRACKET)) {
  expr = finishSubscript(expr);
  } <span class="org-keyword">else</span> {
  <span class="org-keyword">break</span>;
  }
  }
  <span class="org-keyword">return</span> expr;
  }
  </pre>
  </div>
  <p>
  As you may have noticed in the formal grammar, for parsing a l-value expression, the parser extends the <code>assignment</code> rule. If the parsed expression is of type <code>Subscript</code>, it wraps the list&rsquo;s name, index and value expression in a AST node. The list&rsquo;s name is stored as an expression without converting it into l-value because the methods used for manipulating the list act on a evaluated value of the list. 
  </p>
  <div class="org-src-container">
  <pre class="src src-cpp"><span class="org-constant">std</span>::<span class="org-type">shared_ptr</span>&lt;Expr&gt; <span class="org-constant">Parser</span>::<span class="org-function-name">assignment</span>() {
  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span>&lt;Expr&gt; <span class="org-variable-name">expr</span> = logicalOr();
  <span class="org-keyword">if</span> (match(<span class="org-constant">TokenType</span>::EQUAL)) {
  <span class="org-type">Token</span> <span class="org-variable-name">equals</span> = previous();
  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span>&lt;Expr&gt; <span class="org-variable-name">value</span> = assignment();
  <span class="org-comment-delimiter">// </span><span class="org-comment">parse variable assignment</span>
  } <span class="org-keyword">else</span> <span class="org-keyword">if</span> (<span class="org-type">Subscript</span> *<span class="org-variable-name">s</span> = <span class="org-keyword">dynamic_cast</span>&lt;<span class="org-type">Subscript</span> *&gt;(expr.get())) {
  <span class="org-keyword">return</span> <span class="org-constant">std</span>::make_shared&lt;<span class="org-type">Subscript</span>&gt;(s-&gt;name, s-&gt;index, value,
  s-&gt;paren);
  }
  error(<span class="org-constant">std</span>::move(equals), <span class="org-string">"Invalid assignment target."</span>);
  }
  <span class="org-keyword">return</span> expr;
  }
  </pre>
  </div>
  </div>
  </div>
  <div id="outline-container-org9b40d4a" class="outline-4">
  <h4 id="org9b40d4a">Interpreting Subscripts</h4>
  <div class="outline-text-4" id="text-org9b40d4a">
  <p>
  To interpret a subscript expression, the interpreter first evaluates the list&rsquo;s name and index and checks if they are of the correct type. If they pass the type checks, the interpreter casts the list&rsquo;s name to the runtime&rsquo;s representation of a list and the index to <code>int</code> from <code>double</code><sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup>. Checking if the index is out of range is done at the last moment as they should be handled differently for l-value and r-value. 
  </p>

  <p>
  Now the interpreter knows that the list and the index are of valid types and is ready interpret it. If the AST node has a value expression, the interpreter evaluates it and assigns it at the index. List&rsquo;s <code>setAtIndex()</code> method sets a value at a index under two condtions:
  When index is equivalent to length of list: To append a value to the list.
  When index is less than length of list and greater than zero: To assign a value at a index. 
  If neither of those conditions evaluate to a truthy value, the method returns <code>false</code> and the interpreter throws a runtime error. 
  </p>

  <p>
  If the node does <b>not</b> have a value it&rsquo;s a r-value and the interpreter is supposed to return the value at index. It returns the value using the list&rsquo;s method if index is within the range of the list. Otherwise, if the index is out of range, it returns a <code>nullptr</code>.
  </p>
  <div class="org-src-container">
  <pre class="src src-cpp"><span class="org-constant">std</span>::<span class="org-type">any</span> <span class="org-constant">Interpreter</span>::<span class="org-function-name">visitSubscriptExpr</span>(<span class="org-constant">std</span>::<span class="org-type">shared_ptr</span>&lt;Subscript&gt; <span class="org-variable-name">expr</span>) {
  <span class="org-constant">std</span>::<span class="org-type">any</span> <span class="org-variable-name">name</span> = evaluate(expr-&gt;name);
  <span class="org-constant">std</span>::<span class="org-type">any</span> <span class="org-variable-name">index</span> = evaluate(expr-&gt;index);
  <span class="org-keyword">if</span> (name.type() == <span class="org-keyword">typeid</span>(<span class="org-constant">std</span>::<span class="org-type">shared_ptr</span>&lt;ListType&gt;)) {
  <span class="org-keyword">if</span> (index.type() == <span class="org-keyword">typeid</span>(<span class="org-type">double</span>)) {
  <span class="org-constant">std</span>::<span class="org-type">shared_ptr</span>&lt;ListType&gt; <span class="org-variable-name">list</span>;
  <span class="org-type">int</span> <span class="org-variable-name">castedIndex</span>;
  list = <span class="org-constant">std</span>::any_cast&lt;<span class="org-constant">std</span>::<span class="org-type">shared_ptr</span>&lt;ListType&gt;&gt;(name);
  castedIndex = <span class="org-constant">std</span>::any_cast&lt;<span class="org-type">double</span>&gt;(index);
  <span class="org-keyword">if</span> (expr-&gt;value != <span class="org-constant">nullptr</span>) {
  <span class="org-constant">std</span>::<span class="org-type">any</span> <span class="org-variable-name">value</span> = evaluate(expr-&gt;value);
  <span class="org-keyword">if</span> (list-&gt;setAtIndex(castedIndex, value)) {
  <span class="org-keyword">return</span> value; 
  } <span class="org-keyword">else</span> {
  <span class="org-keyword">throw</span> RuntimeError{expr-&gt;paren, <span class="org-string">"Index out of range."</span>};
  }
  } <span class="org-keyword">else</span> {
  <span class="org-keyword">if</span> (castedIndex &gt;= list-&gt;length() || castedIndex &lt; 0) {
  <span class="org-keyword">return</span> <span class="org-constant">nullptr</span>;
  }
  <span class="org-keyword">return</span> list-&gt;getEleAt(castedIndex);
  }
  } <span class="org-keyword">else</span> {
  <span class="org-keyword">throw</span> RuntimeError{expr-&gt;paren, <span class="org-string">"Index should be of type int."</span>};
  }
  } <span class="org-keyword">else</span> {
  <span class="org-keyword">throw</span> RuntimeError{expr-&gt;paren, <span class="org-string">"Only lists can be subscripted."</span>};
  }
  <span class="org-keyword">return</span> {};
  }
  </pre>
  </div>
  <p>
  I could have made the interpreter throw errors when indexing out of range but chose to return a <code>nullptr</code> because it helps in terminating a loop while iterating over a list. It might seem unsafe but the interpreter throws an error when a variable initialized with <code>nullptr</code> is used in an expression. So if the user tries to access a value out of range and uses it in some other expression, the program is guaranteed to fail. 
  </p>
  <div class="org-src-container">
  <pre class="src src-lox"><span class="org-comment-delimiter">// </span><span class="org-comment">lox script to print all elements in a list</span>
  <span class="org-keyword">var</span> list = [1, 2, 3, 4, 5];
  <span class="org-keyword">for</span> (<span class="org-keyword">var</span> i = 0; list[i] != <span class="org-constant">nil</span>; i = i + 1) {
  <span class="org-builtin">print</span> list[i]; <span class="org-comment-delimiter">// </span><span class="org-comment">1 2 3 4 5</span>
  }
  </pre>
  </div>
  <p>
  Unused Variable Warnings
  I also made the resolver throw warnings when there are unused variables in the local scope. This also solves challenge #3 in chapter 11 <i>Resolving and Binding</i>.
  </p>

  <p>
  To implement this feature, a vector of <code>std::map</code> is used like a stack to track the nested (possibly) local scopes in scope. This is similar to the <code>scopes</code> stack used in the resolver but instead of storing a string and a boolean, here I store the variable as a token and the number of times it has been resolved. When the resolver enters a local scope it pushes an empty map into the vector and when it exits a scope it pops a map. Declaring a variable in the local scope inserts a element with variable token as key and <code>0</code> as value in the top most map. This value gets incremented by one whenever the corresponding variable is resolved locally. Finally, before exiting a local scope calling <code>checkUnusedVariables()</code> would iterate over all the pairs in the top most map and throw a warning when the value is equivalent to zero.
  </p>
  <div class="org-src-container">
  <pre class="src src-cpp"><span class="org-type">void</span> <span class="org-constant">Resolver</span>::<span class="org-function-name">checkUnusedVariables</span>() {
  <span class="org-constant">std</span>::<span class="org-type">map</span>&lt;Token, <span class="org-type">int</span>&gt; &amp;<span class="org-variable-name">currentScope</span> = identifiers.back();
  <span class="org-keyword">for</span> (<span class="org-keyword">auto</span> <span class="org-keyword">const</span>&amp; [<span class="org-constant">key</span>, <span class="org-constant">val</span>] : currentScope) {
  <span class="org-keyword">if</span> (val == 0) {
  <span class="org-constant">Error</span>::warn(key, <span class="org-string">"Unused local variable."</span>);
  }
  }
  }
  </pre>
  </div>
  <p>
  Epilogue
  I had so much fun working on this project and learnt a lot about programming languages and interpreters. Before reading this book, I did not know what actually happens when I run or compile my programs but now I have a better understanding of the underlying ideas and visualize a interpreter as follows:
  </p>

  <p>
  Scanner:
  Converts user input into list of tokens.
  Parser:
  Tokens into expression or statement AST node based on formal grammar.
  Interpreter:
  Evaluates a expression node to a value.
  Executes a statement node to produce side effect.
  Environment:
  Stores the state of the program.
  </p>

  <p>
  Next, I&rsquo;m looking forward to start working on the bytecode interpreter.
  </p>
  </div>
  </div>
  </div>
  ]]></description>
</item>
<div id="footnotes">
  <h2 class="footnotes">Footnotes: </h2>
  <div id="text-footnotes">

    <div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">I'm not sure if this would work when classes and methods are implemented.</p></div></div>

    <div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">This is actually a bug because index number should not be of type <code>double</code></p></div></div>


  </div>
</div></channel>
</rss>
